// -*- C++ -*-
// -----------------------------------------------------------------------------------------------------
// Copyright (c) 2006-2019, Knut Reinert & Freie Universität Berlin
// Copyright (c) 2016-2019, Knut Reinert & MPI für molekulare Genetik
// This file may be used, modified and/or redistributed under the terms of the 3-clause BSD-License
// shipped with this file and also available at: https://github.com/seqan/seqan3/blob/master/LICENSE.md
// -----------------------------------------------------------------------------------------------------

/*!\file
 * \brief Provides C++20 additions to the \<iterator\> header.
 * \author Hannes Hauswedell <hannes.hauswedell AT fu-berlin.de>
 */

#pragma once

#include <iterator>

#ifndef __cpp_lib_ranges

#include <range/v3/iterator/access.hpp>
#include <range/v3/iterator/default_sentinel.hpp>
#include <range/v3/iterator/insert_iterators.hpp>
#include <range/v3/iterator/operations.hpp>
#include <range/v3/iterator/stream_iterators.hpp>

#include <seqan3/std/concepts>

/*!\defgroup iterator iterator
 * \ingroup std
 * \brief The \<iterator\> header from C++20's standard library.
 */

namespace std
{
//!\addtogroup iterator
//!\{

// ------------------------------------------------------------------
// iterator type traits
// ------------------------------------------------------------------

/*!\brief A type trait class that provides uniform interface to the properties of types that model the
 *        weakly_incrementable concept.
 * \tparam t The type to query.
 * \sa https://en.cppreference.com/w/cpp/iterator/incrementable_traits
 */
template <typename t>
struct incrementable_traits
{};

//!\cond
template <typename t>
    requires std::is_object_v<t>
struct incrementable_traits<t*>
{
    using difference_type = ptrdiff_t;
};

template <typename t>
struct incrementable_traits<const t> : incrementable_traits<t>
{};

template <typename t>
    requires requires { typename t::difference_type; }
struct incrementable_traits<t>
{
    using difference_type = typename t::difference_type;
};

template <typename t>
    requires (!requires { typename t::difference_type; } &&
              requires(t const & a, t const & b) { requires integral<decltype(a - b)>; })
struct incrementable_traits<t>
{
    using difference_type = std::make_signed_t<decltype(declval<t>() - declval<t>())>;
};
//!\endcond

//!\cond
namespace detail
{
// The type does not support incrementable concepts.
template <typename t>
struct incrementable_traits_or_iterator_traits
{};

// Use incrementable_traits<t>::difference_type if it is defined.
template <typename t>
    requires requires { typename incrementable_traits<t>::difference_type; }
struct incrementable_traits_or_iterator_traits<t>
{
    using difference_type = typename incrementable_traits<t>::difference_type;
};

// Fall back to iterstor_traits if incrementable_traits<t>::difference_type is not defined.
template <typename t>
    requires (!requires { typename incrementable_traits<t>::difference_type; } &&
               requires { typename iterator_traits<t>::difference_type; })
struct incrementable_traits_or_iterator_traits<t>
{
    using difference_type = typename iterator_traits<t>::difference_type;
};
}
//!\endcond

/*!\brief Defines the incrementable type's difference type
 * \tparam t The type to get the difference type for.
 * \sa https://en.cppreference.com/w/cpp/iterator/iter_t
 */
template <typename t>
using iter_difference_t = typename detail::incrementable_traits_or_iterator_traits<t>::difference_type;

/*!\typedef std::iter_reference_t
 * \brief Alias for ranges::iter_reference_t. Returns the reference type of the iterator.
 */
using SEQAN3_DOXYGEN_ONLY(iter_reference_t = ) ::ranges::iter_reference_t;

// ------------------------------------------------------------------
// auxiliary functions
// ------------------------------------------------------------------

/*!\brief Create a std::back_insert_iterator for the argument.
 * \tparam container_t  Type of the parameter; must have a `push_back()` member function.
 * \param container     The container on which to create the iterator.
 * \returns The respective back insert iterator.
 *
 * \details
 *
 * This function delegates to ranges::back_inserter from range-v3; it is more constrained than a possibly
 * outdated one from the standard library.
 */
template <typename container_t>
//!\cond
    requires requires (container_t & v) { { v.push_back(*v.begin()) }; }
//!\endcond
constexpr auto back_inserter(container_t & container)
{
    return ::ranges::back_inserter(container);
}

// ------------------------------------------------------------------
// Concepts
// ------------------------------------------------------------------

/*!\interface std::readable <>
 * \brief The concept readable is satisfied by types that are readable by applying operator*, such as pointers, smart
 *        pointers, and iterators.
 * \sa https://en.cppreference.com/w/cpp/iterator/readable
 */
//!\cond
template <typename t>
SEQAN3_CONCEPT readable = ::ranges::Readable<t>;

//!\endcond

/*!\interface std::writable <>
 * \brief The concept `writable<Out, T>` specifies the requirements for writing a value whose type and value category
 *        are encoded by T into an iterator Out's referenced object.
 * \sa https://en.cppreference.com/w/cpp/iterator/writable
 */
//!\cond
template <typename out, typename t>
SEQAN3_CONCEPT writable = ::ranges::Writable<out, t>;
//!\endcond

/*!\interface std::weakly_incrementable <>
 * \extends std::Semiregular
 * \brief The concept weakly_incrementable specifies the requirements on a type that can be incremented (with the
 *        pre- and post-increment operators). The increment operations need not be equality-preserving, and the type
 *        need not be std::EqualityComparable.
 * \sa https://en.cppreference.com/w/cpp/iterator/weakly_incrementable
 */
//!\cond
template <typename t>
SEQAN3_CONCEPT weakly_incrementable = semiregular<t> &&
                                   requires (t v)
{
    typename iter_difference_t<std::remove_reference_t<t>>;
    requires signed_integral<iter_difference_t<std::remove_reference_t<t>>>;
    requires same_as<decltype(++v), t &>; /* not required to be equality preserving */
    v++; /* not required to be equality preserving */
};
//!\endcond

/*!\interface std::incrementable <>
 * \extends std::weakly_incrementable
 * \extends std::Regular
 * \brief The concept incrementable specifies the requirements on a type that can be incremented (with the pre-
 *        and post-increment operators). The increment operations (including those required by std::weakly_incrementable)
 *        are required to be equality-preserving, and the type is required to be std::EqualityComparable.
 * \sa https://en.cppreference.com/w/cpp/iterator/incrementable
 */
//!\cond
template <typename i>
SEQAN3_CONCEPT incrementable = regular<i> && weakly_incrementable<i> && ::ranges::Incrementable<i>;
//!\endcond

/*!\interface std::input_or_output_iterator <>
 * \extends std::weakly_incrementable
 * \brief The Iterator concept forms the basis of the iterator concept taxonomy; every iterator satisfies the Iterator
 *        requirements.
 * \sa https://en.cppreference.com/w/cpp/iterator/Iterator
 */
//!\cond
template <typename i>
SEQAN3_CONCEPT input_or_output_iterator = weakly_incrementable<i> && ::ranges::Iterator<i>;
//!\endcond

/*!\interface std::sentinel_for <>
 * \extends std::Semiregular
 * \extends std::input_or_output_iterator
 * \brief The sentinel_for concept specifies the relationship between an std::input_or_output_iterator type and a std::Semiregular type
 *        whose values denote a range.
 * \sa https://en.cppreference.com/w/cpp/iterator/sentinel_for
 */
//!\cond
template <typename s, typename i>
SEQAN3_CONCEPT sentinel_for = semiregular<s> && input_or_output_iterator<i> && ::ranges::Sentinel<s, i>;
//!\endcond

/*!\interface std::sized_sentinel_for <>
 * \extends std::sentinel_for
 * \brief The sized_sentinel_for concept specifies that an object of the iterator type I and an object of the
 *        sentinel type S can be subtracted to compute the distance between them in constant time.
 * \sa https://en.cppreference.com/w/cpp/iterator/sized_sentinel_for
 */
//!\cond
template <typename s, typename i>
SEQAN3_CONCEPT sized_sentinel_for = sentinel_for<s, i> && ::ranges::SizedSentinel<s, i>;
//!\endcond

/*!\interface std::output_iterator <>
 * \extends std::input_or_output_iterator
 * \extends std::writable
 * \brief The output_iterator concept is a refinement of std::input_or_output_iterator, adding the requirement that it can be used
 *        to write values of values of type and value category encoded by T (via std::writable).
 *        std::EqualityComparable is not required.
 * \sa https://en.cppreference.com/w/cpp/iterator/output_iterator
 */
//!\cond
template <typename out, typename t>
SEQAN3_CONCEPT output_iterator = input_or_output_iterator<out> && writable<out, t> && ::ranges::OutputIterator<out, t>;
//!\endcond

/*!\interface std::input_iterator <>
 * \extends std::input_or_output_iterator
 * \extends std::readable
 * \brief The input_iterator concept is a refinement of std::input_or_output_iterator, adding the requirement that the referenced
 *        values can be read (via std::readable) and the requirement that the iterator category tag be present.
 * \sa https://en.cppreference.com/w/cpp/iterator/input_iterator
 */
//!\cond
template <typename i>
SEQAN3_CONCEPT input_iterator = input_or_output_iterator<i> && readable<i> && ::ranges::InputIterator<i>;
//!\endcond

/*!\interface std::forward_iterator <>
 * \extends std::input_iterator
 * \extends std::incrementable
 * \extends std::sentinel_for
 * \brief The input_iterator concept is a refinement of std::input_or_output_iterator, adding the requirement that the referenced
 *        values can be read (via std::readable) and the requirement that the iterator category tag be present.
 * \sa https://en.cppreference.com/w/cpp/iterator/forward_iterator
 */
//!\cond
template <typename i>
SEQAN3_CONCEPT forward_iterator = input_iterator<i> &&
                               incrementable<i> &&
                               sentinel_for<i, i> &&
                               ::ranges::ForwardIterator<i>;
//!\endcond

/*!\interface std::bidirectional_iterator <>
 * \extends std::forward_iterator
 * \brief The concept bidirectional_iterator refines std::forward_iterator by adding the ability to move an iterator
 *        backward.
 * \sa https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator
 */
//!\cond
template <typename i>
SEQAN3_CONCEPT bidirectional_iterator = forward_iterator<i> && ::ranges::BidirectionalIterator<i>;
//!\endcond

/*!\interface std::random_access_iterator <>
 * \extends std::bidirectional_iterator
 * \extends std::sized_sentinel_for
 * \extends std::totally_ordered
 * \brief The concept random_access_iterator refines std::bidirectional_iterator by adding support for constant
 *        time advancement with the +=, +, -=, and - operators, constant time computation of distance with -,
 *        and array notation with subscripting.
 * \sa https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator
 */
//!\cond
template <typename i>
SEQAN3_CONCEPT random_access_iterator = bidirectional_iterator<i> &&
                                    totally_ordered<i> &&
                                    sized_sentinel_for<i, i> &&
                                    ::ranges::RandomAccessIterator<i>;
//!\endcond

/*!\interface std::contiguous_iterator <>
 * \extends std::random_access_iterator
 * \brief The concept contiguous_iterator refines std::random_access_iterator by requiring that for every iterator
 *        `i` and distance `n` where `(a + n)` is a valid iterator `*(a + n)` is equivalent to
 *        `*(std::addressof(*a) + n)`.
 * \sa https://en.cppreference.com/w/cpp/iterator/contiguous_iterator
 */
//!\cond
template <typename i>
SEQAN3_CONCEPT contiguous_iterator = random_access_iterator<i> &&
                                    ::ranges::ContiguousIterator<i>;
//!\endcond

//!\} // Iterator Concepts.

}  // namespace std

namespace std::ranges
{
//!\addtogroup iterator
//!\{

/*!\typedef std::ranges::advance
* \brief Alias for ranges::advance. Advances the iterator by the given distance.
*/
using SEQAN3_DOXYGEN_ONLY(advance =) ::ranges::advance;

/*!\typedef std::ranges::distance
* \brief Alias for ranges::distance. Returns the number of hops from first to last.
*/
using SEQAN3_DOXYGEN_ONLY(distance =) ::ranges::distance;

/*!\typedef std::ranges::prev
* \brief Alias for ranges::prev. Returns the nth predecessor of the given iterator.
*/
using SEQAN3_DOXYGEN_ONLY(prev =)::ranges::prev;

/*!\typedef std::ranges::next
* \brief Alias for ranges::next. Returns the nth successor of the given iterator.
*/
using SEQAN3_DOXYGEN_ONLY(next =) ::ranges::next;

/*!\typedef std::ranges::iter_move
* \brief Alias for ranges::iter_move. Casts the result of dereferencing an object to its associated rvalue reference type.
*/
using SEQAN3_DOXYGEN_ONLY(iter_move =) ::ranges::iter_move;

/*!\typedef std::ranges::iter_swap
* \brief Alias for ranges::iter_swap. Exchanges the values denoted by its arguments.
*/
using SEQAN3_DOXYGEN_ONLY(iter_swap =) ::ranges::iter_swap;

/*!\typedef std::ranges::default_sentinel
* \brief Alias for ranges::default_sentinel. Empty sentinel object for use with iterators that know the bound of their range.
*/
using SEQAN3_DOXYGEN_ONLY(default_sentinel =) ::ranges::default_sentinel;

/*!\typedef std::ranges::default_sentinel_t
* \brief Alias for ranges::default_sentinel_t. Type of ranges::default_sentinel.
*/
using SEQAN3_DOXYGEN_ONLY(default_sentinel_t =) ::ranges::default_sentinel_t;

//!\}
} // namespace std::ranges

#endif // C++17
