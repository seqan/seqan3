// -----------------------------------------------------------------------------------------------------
// Copyright (c) 2006-2020, Knut Reinert & Freie Universität Berlin
// Copyright (c) 2016-2020, Knut Reinert & MPI für molekulare Genetik
// This file may be used, modified and/or redistributed under the terms of the 3-clause BSD-License
// shipped with this file and also available at: https://github.com/seqan/seqan3/blob/master/LICENSE.md
// -----------------------------------------------------------------------------------------------------

/*!\file
 * \author Mitra Darvish <mitra.darvish AT fu-berlin.de>
 * \brief Provides seqan3::views::minimiser.
 */

#pragma once

#include <deque>

#include <seqan3/core/debug_stream.hpp>
#include <seqan3/range/hash.hpp>

namespace seqan3::detail
{
// ---------------------------------------------------------------------------------------------------------------------
// minimiser class
// ---------------------------------------------------------------------------------------------------------------------

/*!\brief The type returned by seqan3::views::minimiser.
 * \tparam urng_t The type of the underlying ranges, must model std::forward_range, the reference type must model
 *                std::size_t. The typical use case is that the reference type is the result of seqan3::kmer_hash.
 * \implements std::ranges::view
 * \implements std::ranges::random_access_range
 * \implements std::ranges::sized_range
 * \ingroup views
 *
 * \details
 *
 * Note that most members of this class are generated by ranges::view_interface which is not yet documented here.
 */
template <std::ranges::view urng_t>
class minimiser : public std::ranges::view_interface<minimiser<urng_t>>
{
private:
    static_assert(std::ranges::forward_range<urng_t const>, "The minimiser only works on forward_ranges");

    //!\brief The underlying range.
    urng_t urange;

    //!\brief The window size to use.
    uint32_t window_size;

    template <typename rng_t>
    class window_iterator;

public:
    /*!\name Constructors, destructor and assignment
     * \{
     */
    minimiser()                                  = default; //!< Defaulted.
    minimiser(minimiser const & rhs)             = default; //!< Defaulted.
    minimiser(minimiser && rhs)                  = default; //!< Defaulted.
    minimiser & operator=(minimiser const & rhs) = default; //!< Defaulted.
    minimiser & operator=(minimiser && rhs)      = default; //!< Defaulted.
    ~minimiser()                                 = default; //!< Defaulted.

    //!\brief Construct from a view and a given window_size.
    minimiser(urng_t urange_, uint32_t const & w_) : urange{std::move(urange_)}, window_size{w_}{}

    //!\brief Construct from a non-view that can be view-wrapped and a given window_size.
    template <typename rng_t>
    //!\cond
     requires !std::same_as<seqan3::remove_cvref_t<rng_t>, minimiser> &&
              std::ranges::viewable_range<rng_t> &&
              std::constructible_from<urng_t, ranges::ref_view<std::remove_reference_t<rng_t>>>
    //!\endcond
    minimiser(rng_t && urange_, uint32_t const & k_, uint32_t const & w_) :
        urange{std::views::all(std::forward<rng_t>(urange_))}, window_size{w_} {}
    //!\}

    /*!\name Iterators
     * \{
     */
    /*!\brief Returns an iterator to the first element of the range.
     * \returns Iterator to the first element.
     *
     * \details
     *
     * ### Complexity
     *
     * Constant.
     *
     * ### Exceptions
     *
     * No-throw guarantee.
     */
    auto begin() noexcept
    {
        return window_iterator<urng_t>{std::ranges::begin(urange), std::ranges::begin(urange) +
                                      (std::ranges::size(urange) - 1), window_size};
    }

    //!\copydoc begin()
    auto begin() const noexcept
    //!\cond
        requires seqan3::const_iterable_range<urng_t>
    //!\endcond
    {
        return window_iterator<urng_t const>{std::ranges::begin(urange), std::ranges::begin(urange) +
                                            (std::ranges::size(urange) - 1), window_size};
    }

    //!\copydoc begin()
    auto cbegin() const noexcept
    //!\cond
        requires seqan3::const_iterable_range<urng_t>
    //!\endcond
    {
        return begin();
    }

    /*!\brief Returns an iterator to the element following the last element of the range.
     * \returns Iterator to the end.
     *
     * \details
     *
     * This element acts as a placeholder; attempting to dereference it results in undefined behaviour.
     *
     * ### Complexity
     *
     * Constant.
     *
     * ### Exceptions
     *
     * No-throw guarantee.
     */
    auto end() noexcept
    {
        return std::ranges::end(urange);

    }

    //!\copydoc end()
    auto end() const noexcept
    //!\cond
        requires seqan3::const_iterable_range<urng_t>
    //!\endcond
    {
        return std::ranges::end(urange);
    }

    //!\copydoc end()
    auto cend() const noexcept
    //!\cond
        requires seqan3::const_iterable_range<urng_t>
    //!\endcond
    {
        return end();
    }
    //!\}
};

template <std::ranges::view urng_t>
template <typename rng_t>
class minimiser<urng_t>::window_iterator
{
private:
    //!\brief The iterator type of the underlying range.
    using it_t = std::ranges::iterator_t<rng_t>;
    //!\brief The sentinel type of the underlying range.
    using sentinel_t = std::ranges::sentinel_t<rng_t>;

public:
    /*!\name Associated types
     * \{
     */
    //!\brief Type for distances between iterators.
    using difference_type = typename std::iter_difference_t<it_t>;
    //!\brief Value type of this iterator.
    using value_type = size_t;
    //!\brief The pointer type.
    using pointer = void;
    //!\brief Reference to `value_type`.
    using reference = value_type;
    //!\brief Tag this class as input iterator.
    using iterator_category = std::input_iterator_tag;
    //!\brief Tag this class depending on which concept `it_t` models.
    using iterator_concept = std::conditional_t<std::contiguous_iterator<it_t>,
                                                typename std::random_access_iterator_tag,
                                                seqan3::iterator_tag_t<it_t>>;
    //!\}

    /*!\name Constructors, destructor and assignment
     * \{
     */
    constexpr window_iterator()                                    = default; //!< Defaulted.
    constexpr window_iterator(window_iterator const &)             = default; //!< Defaulted.
    constexpr window_iterator(window_iterator &&)                  = default; //!< Defaulted.
    constexpr window_iterator & operator=(window_iterator const &) = default; //!< Defaulted.
    constexpr window_iterator & operator=(window_iterator &&)      = default; //!< Defaulted.
    ~window_iterator()                                             = default; //!< Defaulted.

    /*!\brief Construct from a given iterator of std::size_t, a second iterator of std::size_t and a window_size.
    * /param[in] it_start Iterator pointing to the first position of the std::size_t range.
    * /param[in] it_end   Iterator pointing to the last position of the std::size_t range.
    * /param[in] w        The window size to be used.
    *
    * \details
    *
    */
    window_iterator(it_t it_start, it_t it_end, uint32_t w) :
                    last_elem{it_end}, window_left{it_start}, window_right{it_start}, window_size{w}
    {
        if (window_size <= std::distance(window_left, last_elem))
            get_minimiser();
    }
    //!\}

    //!\anchor window_iterator_comparison
    //!\name Comparison operators
    //!\{

    //!\brief Compare to iterator on underlying range.
    friend bool operator==(window_iterator const & lhs, sentinel_t const & rhs) noexcept
    {
        return lhs.window_right == rhs;
    }

    //!\brief Compare to iterator on underlying range.
    friend bool operator==(sentinel_t const & lhs, window_iterator const & rhs) noexcept
    {
        return lhs == rhs.window_right;
    }

    //!\brief Compare to another window_iterator.
    friend bool operator==(window_iterator const & lhs, window_iterator const & rhs) noexcept
    {
        return std::tie(lhs.window_right, lhs.window_size) == std::tie(rhs.window_right, rhs.window_size);
    }

    //!\brief Compare to iterator on  underlying range.
    friend bool operator!=(window_iterator const & lhs, sentinel_t const & rhs) noexcept
    {
        return !(lhs == rhs);
    }

    //!\brief Compare to iterator on underlying range.
    friend bool operator!=(sentinel_t const & lhs, window_iterator const & rhs) noexcept
    {
        return !(lhs == rhs);
    }

    //!\brief Compare to another window_iterator.
    friend bool operator!=(window_iterator const & lhs, window_iterator const & rhs) noexcept
    {
        return !(lhs == rhs);
    }

    //!\brief Compare to another window_iterator.
    friend bool operator<(window_iterator const & lhs, window_iterator const & rhs) noexcept
    {
        return (lhs.window_right < rhs.window_right) && (lhs.window_size < rhs.window_size);
    }

    //!\brief Compare to another window_iterator.
    friend bool operator>(window_iterator const & lhs, window_iterator const & rhs) noexcept
    {
        return (lhs.window_right > rhs.window_right) && (lhs.window_size > rhs.window_size);
    }

    //!\brief Compare to another window_iterator.
    friend bool operator<=(window_iterator const & lhs, window_iterator const & rhs) noexcept
    {
        return (lhs.window_right <= rhs.window_right) && (lhs.window_size <= rhs.window_size);
    }

    //!\brief Compare to another window_iterator.
    friend bool operator>=(window_iterator const & lhs, window_iterator const & rhs) noexcept
    {
        return (lhs.window_right >= rhs.window_right) && (lhs.window_size >= rhs.window_size);
    }
    //!\}

    //!\brief Pre-increment.
    window_iterator & operator++() noexcept
    {
        get_minimiser();
        return *this;
    }

    //!\brief Post-increment.
    window_iterator operator++(int) noexcept
    {
        window_iterator tmp{*this};
        get_minimiser();
        return tmp;
    }

    //!\brief Return the minimiser.
    value_type operator*() const noexcept
    {
        return minimiser_value;
    }

    /*!\brief Forward this iterator.
     * \attention This function is only avaible if `it_t` models std::random_access_iterator.
     */
    window_iterator & operator+=(difference_type const skip) noexcept
    //!\cond
        requires std::random_access_iterator<it_t>
    //!\endcond
    {
        get_minimiser(skip);
        return *this;
    }

    /*!\brief Forward copy of this iterator.
     * \attention This function is only avaible if `it_t` models std::random_access_iterator.
     */
    window_iterator operator+(difference_type const skip) const noexcept
    //!\cond
        requires std::random_access_iterator<it_t>
    //!\endcond
    {
        window_iterator tmp{*this};
        return tmp += skip;
    }

    /*!\brief Non-member operator+ delegates to non-friend operator+.
     * \attention This function is only avaible if `it_t` models std::random_access_iterator.
     */
    friend window_iterator operator+(difference_type const skip, window_iterator const & it) noexcept
    //!\cond
        requires std::random_access_iterator<it_t>
    //!\endcond
    {
        return it + skip;
    }

    /*!\brief Move the iterator by a given offset and return the corresponding minimiser.
     * \attention This function is only avaible if `it_t` models std::random_access_iterator.
     */
    value_type operator[](difference_type const n)
    //!\cond
        requires std::random_access_iterator<it_t>
    //!\endcond
    {
        window_left += n;
        get_minimiser();
        return operator*();
    }

private:
    //!brief Iterator to last element in range.
    it_t last_elem;

    //!brief Keeps track if the minimiser value changed.
    bool minimiser_changed{false};

    //!\brief The minimiser value.
    size_t minimiser_value{0};

    //!\brief Iterator to the leftmost position of the window.
    it_t window_left;

    //!\brief Iterator to the rightmost position of the window.
    it_t window_right;

    //!\brief The window size to use.
    uint32_t window_size;

    //!\brief Stored k-mers per window.
    std::deque<uint64_t> windowValues;

    //!\brief Increments iterator by 1.
    void get_minimiser()
    {
        if (windowValues.size() == 0)
            window_first();
        else
        {
            // Call next_minimiser until minimiser value changed or end of the underlying range is reached.
            while((!minimiser_changed) && (window_right < last_elem))
            {
                next_minimiser();
            }
            if (!minimiser_changed)
            {
                std::ranges::advance(window_left, 1);
                std::ranges::advance(window_right, 1);
            }
        }

        minimiser_changed = false;
    }

    /*!\brief Increments iterator by `skip`.
     * \param skip Amount to increment.
     * \attention This function is only avaible if `it_t` models std::random_access_iterator.
     */
    void get_minimiser(difference_type const skip)
    //!\cond
        requires std::random_access_iterator<it_t>
    //!\endcond
    {
        std::ranges::advance(window_left, skip);
        window_first();
    }

    //!\brief Calculates minimisers for first window.
    void window_first()
    {
        window_right = window_left;

        for (uint32_t i = 0; (i < window_size - 1) ; i++)
        {
            windowValues.push_back(*window_right);
            std::ranges::advance(window_right,  1);
        }
        windowValues.push_back(*window_right);
        minimiser_value = *(std::min_element(std::begin(windowValues), std::end(windowValues)));
    }

    //!\brief Calculates the next minimiser value via rolling hash.
    // For the following windows, we remove the first window k-mer (is now not in window) and add the new k-mer
    // that results from the window shifting
    void next_minimiser()
    {
        //seqan3::debug_stream << windowValues << "\n";
        std::ranges::advance(window_left, 1);
        std::ranges::advance(window_right, 1);
        if (minimiser_value == *(std::begin(windowValues)))
        {
            windowValues.pop_front();
            if (!windowValues.empty())
            {
                minimiser_value = *(std::min_element(std::begin(windowValues), std::end(windowValues)));
                minimiser_changed = true;
            }

        }
        else
        {
            windowValues.pop_front();
        }

        uint64_t kmerHash = *window_right;
        windowValues.push_back(kmerHash);

        if ((windowValues.back() < minimiser_value))
        {
            minimiser_value = *(std::end(windowValues) - 1);
            minimiser_changed = true;
        }
        else if (windowValues.size() == 1)
        {
            minimiser_changed = true;
        }
    }
};

//!\brief A deduction guide for the view class template.
template <std::ranges::viewable_range rng_t>
minimiser(rng_t &&, uint32_t const & window_size) ->
minimiser<std::ranges::all_view<rng_t>>;


// ---------------------------------------------------------------------------------------------------------------------
// minimiser_fn (adaptor definition)
// ---------------------------------------------------------------------------------------------------------------------

//![adaptor_def]
//!\brief views::minimiser's range adaptor object type (non-closure).
struct minimiser_fn
{
    //!\brief Store the window_size and return a range adaptor closure object.
    constexpr auto operator()(uint32_t const & window_size) const
    {
        return seqan3::detail::adaptor_from_functor{*this, window_size};
    }

    /*!\brief               Call the view's constructor with the underlying view and a window size as
     *                      argument.
     * \param[in] urange    The input range to process. Must model std::ranges::viewable_range and the reference type
     *                      of the range must model seqan3::semialphabet.
     * \throws std::invalid_argument if resulting hash values would be too big for a 64 bit integer.
     * \returns             A range of converted elements.
     */
    template <std::ranges::range urng_t>
    constexpr auto operator()(urng_t && urange, uint32_t const & window_size) const
    {
        static_assert(std::ranges::viewable_range<urng_t>,
            "The range parameter to views::minimiser cannot be a temporary of a non-view range.");
        static_assert(std::ranges::forward_range<urng_t>,
            "The range parameter to views::minimiser must model std::ranges::forward_range.");

        return minimiser{urange, window_size};
    }
};
//![adaptor_def]

} // namespace seqan3::detail

namespace seqan3::views
{

/*!\name Alphabet related views
 * \{
 */

/*!\brief               Computes minimisers for each position of a range for a given window size.
 *                      The parameter window size is optional.
 * \tparam urng_t       The type of the range being processed. See below for requirements. [template parameter is
 *                      omitted in pipe notation]
 * \param[in] urange    The range being processed. [parameter is omitted in pipe notation]
 * \returns             A range of std::size_t where each value is the hash of the resp. minimiser.
 *                      See below for the properties of the returned range.
 * \ingroup views
 *
 * \details
 *
 *
 * ### View properties
 *
 * | Concepts and traits              | `urng_t` (underlying range type)   | `rrng_t` (returned range type)   |
 * |----------------------------------|:----------------------------------:|:--------------------------------:|
 * | std::ranges::input_range         | *required*                         | *preserved*                      |
 * | std::ranges::forward_range       | *required*                         | *preserved*                      |
 * | std::ranges::bidirectional_range |                                    | *preserved*                      |
 * | std::ranges::random_access_range |                                    | *preserved*                      |
 * | std::ranges::contiguous_range    |                                    | *lost*                           |
 * |                                  |                                    |                                  |
 * | std::ranges::viewable_range      | *required*                         | *guaranteed*                     |
 * | std::ranges::view                |                                    | *guaranteed*                     |
 * | std::ranges::sized_range         |                                    | *preserved*                      |
 * | std::ranges::common_range        |                                    | *lost*                           |
 * | std::ranges::output_range        |                                    | *lost*                           |
 * | seqan3::const_iterable_range     |                                    | *preserved*                      |
 * |                                  |                                    |                                  |
 * | std::ranges::range_reference_t   | std::size_t                        | std::size_t                      |
 *
 * See the \link views views submodule documentation \endlink for detailed descriptions of the view properties.
 *
 * ### Example
 *
 *
 *
 * \hideinitializer
 */
inline constexpr auto minimiser = detail::minimiser_fn{};

//!\}

} // namespace seqan3::views
